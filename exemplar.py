import sys
import sqlite3  # See reset_db()
import re
from inspect import currentframe, getframeinfo  # For line #
import importlib  # To import and run the test file we create.
import unittest

debug = True  # Set to True for more feedback.
debug_db = True  # True dumps db to screen near the end of each test.

"""
Version 2 finished 10/20/2018 can also generate a while loop. This version can also handle prime_number.exem. 
'reason's are now an unlimited # of conditions.  
Version 1 finished 3/25/2018 can generate one if/elif/else. This version correctly handles fizz_buzz.exem, guess2.exem, 
and leap_year.exem. These 'reason's are 0 or 1 conditions only.

Glossary:
Loop step == Each condition of a loop_likely 'reason' maps to one of a limited # steps that is the target loop.
Pretest == A 'reason' that serves as an IF or ELIF condition above other ELIF/s (in a single if/elif/else).
Reason == The series of (comma-delimited) conditions the user expects will return true for the associated input in the 
target function.  
Target function == The function to be automatically generated by Exemplar from the given examples.
"""


def denude(line) -> str:
    """
    Remove line comment from `line` and return it.
    :param line:  String to denude of possible line comment.
    :return:
    """
    hash_positions = positions_outside_strings(line, '#')
    if not hash_positions:  # Hash not found.
        return line.strip()
    else:
        return line[0:hash_positions[0]].strip()


def positions_outside_strings(string, character) -> list:
    """
    Find and return the positions of the given character, unescaped and outside of strings, in the given string.
    :param string:
    :param character: item to search for.
    :return list of `character` positions, [] if `character` not found:
    """
    positions = []
    open_string = False
    previous_char = ''
    i = 0
    for c in string:
        if c == '"' and previous_char != '\\':
            if not open_string:
                open_string = '"'  # Note we're in a "-delimited string.
            else:  # Already in a string.
                if open_string == '"':  # String closed.
                    open_string = False
        # Repeat above, for single quote.
        if c == "'" and previous_char != '\\':
            if not open_string:
                open_string = "'"
            else:
                if open_string == "'":
                    open_string = False
        if c == character and not open_string and previous_char != '\\':
            positions.append(i)
        previous_char = c  # Set up for next iteration.
        i += 1
    return positions


def remove_c_labels(trace_line) -> str:
    """
    Created 2018-10-13.
    For each "c" found:
        Remove it if it is not quoted AND character to left is a digit AND character to right (if present) is not
        alphanumeric.
    Example: 'i1 % (i1-1) != 0c, (i1-1)>2c' --> 'i1 % (i1-1) != 0, (i1-1)>2'
    :param trace_line:
    :return return_value The trace_line without its c labels:
    """
    if not hasattr(trace_line, '__iter__'):  # trace_line isn't iterable.
        return trace_line
    open_string = False
    check_for_alphanumeric = False
    return_value = ""
    previous_character = ""
    for character in trace_line:
        if character == '"' and previous_character != '\\':
            if not open_string:
                open_string = '"'  # Note we're in a "-delimited string.
            else:  # Already in a string.
                if open_string == '"':  # String closed.
                    open_string = False
        # Repeat above, for single quote.
        if character == "'" and previous_character != '\\':
            if not open_string:
                open_string = "'"
            else:
                if open_string == "'":
                    open_string = False

        if check_for_alphanumeric:
            if not character.isalnum():
                return_value = return_value[0:-1]  # Elide prior "c".

        if character == "c" and previous_character.isdigit():
            check_for_alphanumeric = True  # Check during next character's processing (or after loop if at end of
            # trace_line).
        else:
            check_for_alphanumeric = False

        previous_character = character  # Set up for next iteration.
        return_value += character  # return_value built one character at a time.

    # After loop.
    if check_for_alphanumeric:  # Last two characters were a digit and "c".
        return_value = return_value[0:-1]

    return return_value


def final_condition(reason) -> str:
    """
    Find the last condition in reason. (This is useful because often it's a loop-termination condition.)
    E.g., 'i1 % (i1-1) != 0c, (i1-1)>2c' --> '(i1-1)>2c'
    :param reason:
    :return the last condition in reason:
    """
    commas = positions_outside_strings(reason, ',')
    if not commas:  # `reason` does not have multiple conditions.
        return reason
    return reason[commas[-1] + 1:].strip()  # return last condition.


def schematize(condition) -> str:
    """
    Could have been called replace_increment('_') because finds the increment in the given condition and replaces it
    with underscore. Used to match iterations of the same loop step.  Example:
    Matching starts--v here. v--ends here.
          'i1 % (len(i1)-13) <= 0c'  ->
          'i1 % (len(i1)-_) <= 0c'
    :param condition:
    :return 'condition' with the relop and dec/increment replaced with underscore:
    """
    regex = re.compile(r'('         # Start of capture group 1.
                       r'i'         # i                         i
                       r'\d+'       # #                         1
                       r'\)*'       # optional right parens     )
                       r'\s?'       # optional space            
                       r'(\+|-)'    # +|-                       -
                       r'\s?'       # optional space            
                       r'(\+|-)?'   # optional +|-              
                       r')'         # End of capture group 1.   
                       r'\d+'       # #                         13
                       r'('         # Start of capture group 4.
                       r'\)*'       # optional right parens     )
                       r'\s?'       # optional space    
                       r'((==)|(!=)|(>=)|>|(<=)|<)?'  # optional relop, e.g., <=
                       r')')  # End of capture group 4. (Groups 2 and 3 are within group 1.)
    return regex.sub(r'\1_\4', condition)


def parse_trace(examples) -> None:
    """
    Go through .exem file to build `examples` table (with columns input, output, reason, cnd_count), and the
    termination table (with columns final_cond, output).
    """
    previous_line = 'blank'
    reason = None
    triple_quote = "'''"
    examples += "\n"  # To make sure last example is processed.
    termination = {}  # Just to avoid unneeded Inserts.
    for tr_line in examples:
        tr_line = denude(tr_line)  # Remove # comment if present.
        if previous_line == 'blank':  # BLANK, INPUT or DOCSTRING
            # Currently on a blank or input line or the start of a multi-line comment.
            # assert tr_line, "Current blank line should be a line demo'ing input or start of a multi-line string"

            if tr_line.startswith('"""') or tr_line.startswith("'''"):
                if tr_line.startswith('"""'):
                    triple_quote = '"""'  # Instead of single quotes.
                previous_line = 'multi-line string'  # Will now skip lines until end of docstring.
            elif tr_line:
                # Define inp
                if tr_line.isdigit():
                    inp = int(tr_line)
                else:
                    inp = tr_line
                previous_line = 'input'
            else:
                previous_line = 'blank'

        elif previous_line == 'multi-line string':  # DOCSTRING
            if tr_line.startswith(triple_quote):  # Comment has ended.
                previous_line = 'blank'  # Get ready to look for a line demo'ing input.

        elif previous_line == 'input':  # OUTPUT
            # Then up to an output line, which is a Python expression.
            assert tr_line, "Current blank line should be an output line"
            output = remove_c_labels(tr_line)
            previous_line = 'output'

        elif previous_line == 'output':  # BLANK or REASON
            # Then up to a blank or reason line.
            # assert tr_line, "Blank line found where there should be a reason explaining the above i/o example"
            if tr_line:
                reason = remove_c_labels(tr_line)
                previous_line = 'reason'
            else:  # No `reason` given.
                cursor.execute('''INSERT INTO examples (inp, output, cond_cnt) VALUES (?,?,?)''',
                               (inp, remove_c_labels(output), 0))  # All columns TEXT
                previous_line = 'blank'

        elif previous_line == 'reason':  # Current line is BLANK or a REASON continuation.
            # assert not tr_line, "line `" + tr_line + "` should instead be whitespace"
            if tr_line:
                reason += ' ' + remove_c_labels(tr_line)  # Remember additional tr_line then loop.
            else:
                # `reason` complete.

                # Sanity check: confirm that each (schematized) final condition triggers identical output.
                # E.g., both 'i1 % (i1-2) == 0c' and 'i1 % (i1-4) == 0c' would
                # schematize to 'i1 % (i1-_) _ 0c' so should correlate to identical output (e.g., False).
                # MAY need to ignore examples not loop_likely from sanity check.
                last_cond = remove_c_labels(final_condition(reason))
                # todo Needs refinement because it's not necessarily an error to have duplicate "schema" pointing
                # to the same output, as my_split.exem proved 10/23/18.
                slast_cond = schematize(last_cond)  # schematize() necessary to avoid too many conditions in the WHILE line.
                if slast_cond not in termination:  # if last_cond not in termination:
                    cursor.execute('''INSERT INTO termination (final_cond, output) VALUES (?,?)''',
                                   (last_cond, output))
                    termination[slast_cond] = output
                elif termination[slast_cond] != output:
                    print('Error: terminating condition', last_cond, 'is to output both', output, 'and',
                          termination[slast_cond])
                    exit()
                cursor.execute('''INSERT INTO examples (inp, output, reason, cond_cnt) VALUES (?,?,?,?)''',
                               (inp, output, reason,                               # 1st 3 columns TEXT.
                                1 + len(positions_outside_strings(reason, ','))))  # 1 + # of commas == # of conditions in 'reason'
                reason = None
                previous_line = 'blank'

        else:
            assert True, "Unrecognized previous_line `" + previous_line + "`"
    # assert previous_line == 'blank', ".exem file unexpectedly ended with line of type " + previous_line


def mark_loop_likely() -> None:
    """
    Update the loop_likely column in tables examples and termination.
    :return void:
    """
    # Mark the loop_likely examples:
    # 'Boolean' column loop_likely is set true for
    # 1) all multi-condition examples, plus
    # 2) any others with an exact match on its 'reason' among the conditions of multi-condition examples.
    cursor.execute('''UPDATE examples SET loop_likely = 1 WHERE cond_cnt > 1 OR 
        inp IN (SELECT e1.inp FROM examples e1 WHERE INSTR(e1.reason, reason) AND e1.cond_cnt > 1)''')

    # Now use those newly marked examples to update the termination table.
    cursor.execute('''SELECT reason FROM examples WHERE loop_likely == 1''')
    final_conditions = ""
    looping = cursor.fetchall()
    for reason in looping:
        final_conditions += "'" + final_condition(reason[0]) + "',"
    final_conditions = final_conditions[0:len(final_conditions)-1]
    if len(looping) > 0:
        cursor.execute('UPDATE termination SET loop_likely = 1 WHERE final_cond IN (' + final_conditions + ')')


def remove_all_c_labels() -> None:
    # The "c" labels are not needed. (Constants can have a "c" suffix in `reason` and
    # `output`.) Since they interfere with eval(), update each such record to remove_c_labels().
    cursor.execute('''SELECT inp, output, reason FROM examples''')  # WHERE loop_likely = 0''')
    non_looping = cursor.fetchall()
    for example in non_looping:
        inp = example[0]
        output = remove_c_labels(example[1])
        reason = remove_c_labels(example[2])
        query = "UPDATE examples SET output = "
        query += "'" + output + "'"
        if reason:
            query += ", reason = '" + reason + "'"
        query += " WHERE inp = '" + inp + "'"
        cursor.execute(query)


def build_reason_evals() -> None:
    """
    Using the data of the `examples` table, build a `reason_evals` table that has columns for
    inp (text), `reason` (text), and reason_value (Boolean).
    Most important for if/elif/else generation is reason_value, which shows whether each inp, substituted for i1 in
    each `reason`, yields true or false.
    """
    # For every `reason` and `inp`, calculate and insert `reason_value` and reason_explains_io into `reason_evals`.

    # All reasons not involved in looping.
    cursor.execute('''SELECT DISTINCT reason FROM examples WHERE reason IS NOT NULL AND loop_likely = 0''')
    all_reasons = cursor.fetchall()

    # All inputs not involved in looping.
    cursor.execute('''SELECT          inp    FROM examples WHERE reason IS NOT NULL AND loop_likely = 0''')
    all_inputs = cursor.fetchall()
        
    locals_dict = locals()  # Used in our exec() calls.

    if debug:
        print("Function", getframeinfo(currentframe()).function, "line #", getframeinfo(currentframe()).lineno)
    for a_reason in all_reasons:
        a_reason = a_reason[0]  # There is only element 0.

        for an_inp in all_inputs:  # All inputs.
            an_inp = an_inp[0]
            if an_inp.isdigit():  # Let numbers be numbers (rather than text).
                an_inp = int(an_inp)

            # Substitute an_inp for i1 in a_reason and exec() to see if true or false.
            exec("reason = " + a_reason, {"i1": an_inp}, locals_dict)
            reason_value = locals_dict['reason']

            # Determine and store reason_explains_io, which indicates whether inp is associated with 'reason'
            # in the examples.
            cursor.execute('''SELECT * FROM examples WHERE reason = ? AND inp = ? AND loop_likely = 0''',
                           (a_reason, an_inp,))
            if cursor.fetchone():  
                # Yes, the current an_inp value is associated with a_reason in the user's examples.
                reason_explains_io = 1  
            else:
                reason_explains_io = 0

            if debug:
                print("input:", an_inp, " reason:", a_reason, " reason_explains_io:", reason_explains_io,
                      " reason_value:", reason_value)  # (Sqlite inserts Python None values as null.)

            # Store determinations.
            cursor.execute('''INSERT INTO reason_evals VALUES (?,?,?,?)''',
                           (an_inp, a_reason, reason_explains_io, reason_value))
    if debug:
        print()


def find_safe_pretests() -> None:
    """
    For if/elif/else generation.
    Build table pretests that shows for every reason A, each reason ("safe pretest") B that is *false* with *all* of A's
    example inputs (thereby allowing those inputs to reach A if B was listed above it in an if/elif).
    """

    # All if/elif/else reasons.
    cursor.execute('''SELECT DISTINCT reason FROM examples WHERE reason IS NOT NULL AND loop_likely = 0''')
    all_reasons = cursor.fetchall()

    # Here we find the safe pretests to a_reason (again, those `reason`s false with all of a_reason's inputs).
    for a_reason in all_reasons:
        a_reason = a_reason[0]  # The zeroth is the only element.

        sql = """
            SELECT DISTINCT reason AS potential_pretest FROM reason_evals WHERE 0 = -- 0x that potential_pretest  
                (SELECT count(*) FROM reason_evals re2 WHERE re2.reason = 
                potential_pretest AND re2.reason_value = 1                          -- is true 
                AND re2.inp IN (SELECT e.inp FROM examples e WHERE e.reason == ? AND e.loop_likely = 0)) -- with input  
              """  # given with a_reason (below).
        # E.g., 'i1 % 5 == 0' is a legal pretest to 'i1 % 3 == 0' (and v.v.) in Fizz_Buzz because example inputs for the
        # latter, such as 3 and 9, are not also evenly divisible by 5. And an input that is, such as 15, is an example
        # input for neither.
        cursor.execute(sql, (a_reason,))
        pretests = cursor.fetchall()  # E.g., ('i1 % 3 == 0 and i1 % 5 == 0',)
        for pre in pretests:  # Store each.
            pre = pre[0]                                # (pretest, condition)
            cursor.execute("""INSERT INTO pretests VALUES (?,?)""", (pre, a_reason))  # All columns TEXT


def reset_db() -> None:
    """
    Clear database and redefine its metadata (only).
    :return: None
    """
    db = sqlite3.connect(':memory:')
    global cursor  # So db is available to all functions.
    cursor = db.cursor()

    # The user's examples.
    cursor.execute('''DROP TABLE IF EXISTS examples''')
    cursor.execute('''CREATE TABLE examples(inp TEXT PRIMARY KEY NOT NULL, 
                        output TEXT NOT NULL, 
                        reason TEXT,
                        cond_cnt INTEGER NOT NULL,
                        loop_likely INTEGER NOT NULL DEFAULT 0)''')
    cursor.execute('''CREATE UNIQUE INDEX i ON examples(inp)''')  # Not automatic for Sqlite's primary keys.

    # todo add loop id (prolly line # in target function) as primary key
    cursor.execute('''DROP TABLE IF EXISTS termination''')
    cursor.execute('''CREATE TABLE termination (final_cond TEXT PRIMARY KEY NOT NULL, -- unschematized 
                        output TEXT NOT NULL,
                        step_num INTEGER, -- 0-based index
                        loop_step TEXT, -- first and original 'condition' of related loop step
                        loop_likely INTEGER NOT NULL DEFAULT 0)''')
    cursor.execute('''CREATE UNIQUE INDEX f ON termination(final_cond)''')

    # (Table `reason_evals` shows how every `reason` evaluates across every example input.)
    # For if/elif/else generation.
    cursor.execute('''DROP TABLE IF EXISTS reason_evals''')
    cursor.execute('''CREATE TABLE reason_evals(inp TEXT NOT NULL, 
                        reason TEXT NOT NULL, 
                        reason_explains_io INTEGER NOT NULL, -- 1 iff this inp has this reason in examples  
                        reason_value INTEGER NOT NULL)''')
    cursor.execute('''CREATE UNIQUE INDEX ir ON reason_evals(inp, reason)''')
    # (Column reason_explains_io isn't being used as of 3/9/18.)

    # (Table `pretests` shows for every `reason` those that can be listed above it in an elif.)
    # For if/elif/else generation.
    cursor.execute('''DROP TABLE IF EXISTS pretests''')
    cursor.execute('''CREATE TABLE pretests(pretest TEXT NOT NULL, 
                        condition TEXT NOT NULL)''')
    cursor.execute('''CREATE UNIQUE INDEX ipc ON pretests(pretest, condition)''')


def find_rel_op(condition) -> tuple:
    """
    Return the position of condition's relational operator.
    :param condition:
    :return two string positions, or () if a rel op is not found
    """
    open_string = False
    previous_character = ""
    i = 0
    start = 0
    stop = 0
    for character in condition:
        if character == '"' and previous_character != '\\':
            if not open_string:
                open_string = '"'  # Note we're in a "-delimited string.
            else:  # Already in a string.
                if open_string == '"':  # String closed.
                    open_string = False
        # Repeat above, for single quote.
        if character == "'" and previous_character != '\\':
            if not open_string:
                open_string = "'"
            else:
                if open_string == "'":
                    open_string = False
        if not start:  # Looking for >, <, ==, <=, >=, and !=.
            if not open_string and (character == '>' or character == '<' or character == '=' or character == '!'):
                start = i
        else:  # Now looking for end of relational operator.
            if character == '=':  # This is the only legal 2nd character for a rel op.
                stop = i + 1
            else:  # Relational operator found must have been > or <.
                if condition[i-1] != '>' and condition[i-1] != '<':
                    exit("Misplaced", condition[i-1], "character found in condition", condition)
                stop = i
            break
        i += 1

    if not stop:
        return ()
    return start, stop


def same_step(loop_step, condition) -> int:
    """
    Determine whether condition1 and condition2 represent the same loop step of a 'reason' while-loop, which they do iff
    o they share an identical side,
    o their non-identical sides vary at most in variable-value/s (Is it better to say dec/increment?).
    E.g., same_step("i1 % (i1-_) != 0", "i1 % (i1-1) != 0") --> True
    :param loop_step: a condition from loop_steps
    :param condition: current condition
    #:param last_condition: was needed when: last condition's rel op must change to terminate loop
    :return Boolean:
    """
    # opposite_rel_op = {'==': '!=', '!=': '==', '>': '<=', '<=': '>', '<': '>=', '>=': '<'}

    pos1 = find_rel_op(loop_step)

    pos2 = find_rel_op(condition)
    if not pos1:
        print("No relational operator found in", loop_step)
    if not pos2:
        print("No relational operator found in", condition)

    # rel1 = condition1[pos1[0]:pos1[1]]
    # rel2 = condition2[pos2[0]:pos2[1]]
    # my_split disproved 10/23/18 old "hurdle 1", viz., if rel1 == rel2 or (last_condition and rel1 != rel2)
    if loop_step[0:pos1[0]] == condition[0:pos2[0]]:  # Left sides identical.
        return schematize(loop_step[pos1[1]:]) == schematize(condition[pos2[1]:])  # Check other side.
    elif loop_step[pos1[1]:] == condition[pos2[1]:]:  # Right sides identical.
        return schematize(loop_step[0:pos1[0]]) == schematize(condition[0:pos2[0]])  # Check "    "
    return False


def list_conditions(reason) -> list:
    """
    Determine 'reason's list of conditions. Done in two steps so that we can strip() away whitespace.
    :param reason: str
    :return list of conditions, e.g., ["i1 % (i1-1) != 0c","(i1-1)==2c"]:
    """
    commas = positions_outside_strings(reason, ',')
    conditions = []
    start = 0
    for comma in commas:
        condition = reason[start: comma]
        conditions.append(condition.strip())
        start = comma + 1
    conditions.append(reason[start:].strip())  # Append last condition in 'reason'
    return conditions


def get_inc_int_pos(condition) -> tuple:
    """
    Find and return the start and stop+1 positions of the increment integer. Example: i1 % (i1-1) != 0c --> (9, 10)
    :param condition: non-schematized
    :return _pos: (start, stop+1) tuple of positions of given condition's increment integer. Or () iff missing.
    """

    # Collect any initial underscore positions into _positions.
    start = 0
    _positions = []
    for i in range(0, condition.count('_')):
        _positions.append(condition.find('_', start))
        start = _positions[-1] + 1

    schema = schematize(condition)  # Replaces dec/increment in condition with a single underscore.

    if schema.count('_') < 1:
        return ()  # schematize() found no dec/increment value in condition.  ERROR?

    # Underscores initially found?  1 of the removed values is multiple digits long?
    if len(_positions) > 0 and len(schema)+1 < len(condition):
        # Code a fix if not a very rare situation.
        print("get_increment() cannot handle abs(increments) >9 when condition has pre-existing underscores")
        exit()

    if schema.count('_') > (len(_positions) + 1):
        print("Error: multiple increments found in", condition)
        exit()

    # Build return value from the digit/s found at the position of the new _.
    start = 0
    for i in range(0, schema.count('_')):  # Keep checking underscores
        _pos = schema.find('_', start)     # until new one found.
        if _pos not in _positions:  # *********** NEW _ POSITION *****
            start = _pos
            while condition[_pos].isdigit():
                _pos += 1
            return start, _pos      # *********** RETURN ***********
        start = _pos + 1
    return ()  # No increment found.  ERROR?


def get_increment(condition) -> int:
    """
    Find and return the increment in the given condition.
    E.g., 'i1 % (i1-1) != 0c' --> -1
    :param condition: str
    :return signed increment, 0 if none found:
    """

    _pos = get_inc_int_pos(condition)
    if not _pos:  # _ not found
        return 0
    increment = int(condition[_pos[0]:_pos[1]])

    # Determine the increment's sign.
    sign = 1
    schema = schematize(condition)
    i_pos = schema.rfind('i', 0, _pos[0])  # Find rightmost 'i' from schema[0] to schema's (replaced) increment.
    signs = []
    for j in range(i_pos, _pos[0]):
        if schema[j] == '+' or schema[j] == '-':
            signs.append(schema[j])
    if len(signs) > 2:
        print("Error: >2 +/- signs found in schema substring", schema[i_pos: _pos[0]+1])
        exit()
    elif len(signs) == 0:
        print("Error: No +/- signs found in schema substring", schema[i_pos: _pos[0]+1])
        exit()
    elif len(signs) == 1:
        if signs[0] == '-':
            sign = -1
    else:
        if signs[0] != signs[1]:  # + - or - +
            sign = -1

    return sign * increment


def define_loop(loop_likely_reasons) -> tuple:
    """
    Decipher the loop by noting its sequence of conditions. Define and return loop_steps, loop_step_increments and
    update the termination table.
    # todo figure out what to do about steps not given, e.g., (i1-1)>2c, if printing step errors isn't enough.
    :param loop_likely_reasons: list
    :return loop_steps, loop_step_increments:
    """
    loop_width = 0
    first_condition = ""
    loop_steps = []  # Are here built.
    loop_step_increments = []  # The change to an input variable before each condition's relational operator (includes
    # *all* reasons (perhaps uselessly)).
    for reason in loop_likely_reasons:
        reason = reason[0]  # 0 is the only key.
        last_condition_of_reason = False
        i = 0  # Count of conditions examined in this 'reason'.
        conditions = list_conditions(reason)
        for condition in conditions:
            increment = get_increment(condition)

            if i == (len(conditions) - 1):
                last_condition_of_reason = True
            if not loop_width:  # Still width-finding.
                if not first_condition:
                    first_condition = condition  # Needed to determine when we've cycled back to loop start.
                    loop_steps.append(condition)  # Save condition.
                else:
                    if same_step(first_condition, condition):  # Loop defined!: We've cycled back to loop start.
                        loop_width = i  # Note # of steps in while-loop. (i is correct because we're 1 past.)
                    else:  # Widen loop.
                        loop_steps.append(condition)

            if loop_width and i > loop_width:  # > needed because i resets to zero with each 'reason'.
                # While-loop already plumbed, so SANITY CHECK the `condition`, two ways.

                # 1. Each loop step must, aside from its specific increment, match its analogue in the initial loop.
                if not same_step(loop_steps[i % loop_width], condition):
                    # E.g., on step (ordinal #) 2 of a width (cardinal #) 2 loop, we must be back on step 0.
                    print("Error: Step type", schematize(loop_steps[i % loop_width]), "expected, step",
                          schematize(condition), "detected. i, loop_width, and loop_steps:\n", str(i), str(loop_width),
                          "\n", loop_steps)
                    exit()

                # 2. In this single reason, the latest increment change (for this step) must equal the initial
                # increment (for this step).
                # E.g., -2    -                     [2 - 2]                !=                     [2 % 2]        at i==2
                if (increment - loop_step_increments[i - len(loop_steps)]) != loop_step_increments[i % len(loop_steps)]:
                    print("Error: Increment", increment, "is unexpected")
                    print("loop_step_increments[i - len(loop_steps)] =", loop_step_increments[i - len(loop_steps)])
                    print("loop_step_increments[i % len(loop_steps)] =", loop_step_increments[i % len(loop_steps)])
                    print("And as a result,", str(increment - loop_step_increments[i - len(loop_steps)]), "!=",
                          loop_step_increments[i % len(loop_steps)],
                          "per\n (increment - loop_step_increments[i - len(loop_steps)]) != loop_step_increments[i % len(loop_steps)]")
                    exit()

            # Once for each final_cond, note its loop_step and step_num in the terminations table.
            if last_condition_of_reason:
                # Sanity check.
                if loop_width == 0:
                    print("Error: loop_width is zero at last condition. i =", i, "loop_steps =", loop_steps, "reason =",
                          reason)
                    exit()
                query = 'UPDATE termination SET ' + \
                        'step_num = ' + str(i % loop_width) + ", loop_step = '" + loop_steps[i % loop_width] + \
                        "' WHERE loop_step IS NULL AND final_cond = '" + final_condition(reason) + "'"
                print("query =", query)
                cursor.execute(query)

            loop_step_increments.append(increment)
            i += 1
    return loop_steps, loop_step_increments


def gen_code() -> str:
    """
    Use the info in the tables to generate Python if/elif/else and while loops.
    todo refactor
    :return: Python code
    """

    # Pull the IF/ELIF/ELSE conditions, in that order. (Reasons where loop_likely==0 map to conditions 1:1.)
    sql = """
        SELECT DISTINCT reason AS r1 FROM examples WHERE reason IS NOT NULL AND loop_likely = 0
            ORDER BY (SELECT COUNT(*) FROM pretests WHERE pretest = r1) DESC, LENGTH(reason) DESC, 
            inp -- (for order stability) 
         """
    cursor.execute(sql)
    conditions = cursor.fetchall()  # E.g., [('i1 % 5 == 0',), ('i1 % 3 == 0',)]

    # The most selective condition, i.e., the one that can most commonly serve as a pretest, should be the IF condition.
    # (+1 Insightful)
    # todo To help diagnose user error, add a test ensuring that this 'reason' is a valid pretest to all other 'reason's
    code = "if " + conditions[0][0] + ":\n"
    code += "    return " + gen_return(conditions[0][0]) + '\n'
    del(conditions[0])  # IF is done.

    # Add the ELIF and ELSE conditions and their consequents based on the same criteria (order from the SELECT).
    for condition in conditions:
        condition = condition[0]
        if condition == "True":  
            code += "else:\n"
        else:
            code += "elif " + condition + ":\n"
        code += "    return " + gen_return(condition) + '\n'

    # Pull the WHILE conditions.
    sql = """
        SELECT DISTINCT reason AS r1 FROM examples WHERE reason IS NOT NULL AND loop_likely = 1 ORDER BY cond_cnt DESC, 
        inp -- (for order stability) 
         """
    cursor.execute(sql)
    loop_likely_reasons = cursor.fetchall()  # E.g., [('i1 % 5 == 0',), ('i1 % 3 == 0',)]
    if len(loop_likely_reasons) == 0:
        return code  # *********************************** RETURNing because no WHILE loop ***

    loop_steps, loop_step_increments = define_loop(loop_likely_reasons)  # *** DEFINE_LOOP() ***
    print("loop_steps:", loop_steps)
    print("increments:", loop_step_increments)

    # Loop info has been collated. Now generate loop code using found steps, termination conditions, and return values.

    i = 1
    code += "\n"
    for step in loop_steps:
        code += "accum" + str(i) + " = " + str(-1 * loop_step_increments[i-1]) + "\n"  # E.g., "accum1 = 1\n"
        i += 1

    # Add: WHILE the termination conditions are NOT met, ANDed.
    code += "while "
    cursor.execute('''SELECT final_cond, output, loop_step FROM termination WHERE loop_likely = 1 ORDER BY step_num''')
    terminations = cursor.fetchall()
    assert len(terminations) > 0, "Error: Nothing found in termination table"

    i = 1  # Start at 1 for user-facing names.
    for row in terminations:  # Write while's condition and set up termination list.
        last_cond, output, loop_step = row  # E.g., ['(i1-3)==2c', 'True', '(i1-1)>2c']
        # Replace original condition's dec/increment with one of our accumulators.
        _pos = get_inc_int_pos(loop_step)
        # Remove its "c" labels.
        code += remove_c_labels(loop_step[0:_pos[0]] + "accum" + str(i) + loop_step[_pos[1]:]) + " and "
        # So that could be: += "(i1-accum1)>2 and "
        i += 1
    code = code[0:len(code)-5] + ":\n"  # Clip off last " and ", and WHILE line finalized with ":\n"
    # E.g., "while i1 % (i1-accum1) != 0 and (i1-accum2)>2:\n"

    # Within the loop, each step's accumulator must increment.
    i = 1
    for step in loop_steps:
        code += "    accum" + str(i) + " += " + str(-1 * loop_step_increments[i - 1]) + "\n"
        i += 1
    # E.g., \taccum1 += 1

    # Loop done, now add the if/elif/else gauntlet of termination conditions with payload.
    # cursor.execute('select final_cond, output from termination where loop_likely=1 order by step_num')
    # terminations = cursor.fetchall()
    code += "if "
    i = 1
    for row in terminations:
        last_cond, output, loop_step = row
        _pos = get_inc_int_pos(last_cond)  # E.g., (5, 6)
        code += remove_c_labels(last_cond[0:_pos[0]] + "accum" + str(i) + last_cond[_pos[1]:])
        code += ":\n    return " + output + "\nelif "  # ELIF and RETURN
        i += 1
    code = code[0:len(code)-5]  # Clip off "elif "
    # E.g., i1 % (i1-accum1) == 0:\n\treturn False

    return code


def gen_return(reason) -> str:
    """
    From given 'reason', find and return the corresponding given 'output' from the examples table.
    E.g., 'i1 == 2c' --> "True"
    N.B. 'reason' must pre-exist in examples table.
    N.B. So far this function is for if/elif/else generation only.
    N.B. Even though the same `reason` may be re-used across examples, as long as there's only one IF, `reason` is
    sufficient to determine the output because the output can reference input only via variables (i1, i2, ...).
    :param reason: text
    :return: the output the user associated with the given reason in his/her examples.
    """
    cursor.execute('''SELECT output FROM examples WHERE reason=?  AND loop_likely = 0 LIMIT 1''', (reason,))
    return cursor.fetchone()[0]


def dump_table(table) -> str:
    """
    SHOW EXAMPLE............
    (Called when global variable debug_db is True.)
    :return void:
    """
    cursor.execute('''SELECT * FROM ''' + table)
    all_rows = cursor.fetchall()
    print_me = "all " + table + ":\n("
    for description in cursor.description:
        print_me += description[0] + ", "
    print_me = print_me[0:-2] + ")\n"  # Rtrim last ", "
    for row in all_rows:
        print_me += '('
        for column in row:
            if type(column) == str:
                print_me += "'" + str(column) + "', "
            else:
                print_me += str(column) + ", "
        print_me = print_me[0:-2] + "),\n"
    return '[' + print_me[0:-2] + ']'  # Rtrim last ',\n'


def gen_tests(f_name):
    """
    Generate the text of a unit test file that exercises the target function with the given i/o.
    """
    cursor.execute('''SELECT inp, output FROM examples''')
    all_examples = cursor.fetchall()
    code = ""
    i = 1  # For appending to the test name.
    for row in all_examples:
        inp, output = row
        code += "def test_" + f_name + str(i) + "(self):\n"
        code += "    i1 = " + inp + "\n"  # (i1 may be referenced by output as well.)
        code += "    self.assertEqual(" + output + ", " + f_name + "(i1))\n\n"
        i += 1
    return code


def underscore_to_camelcase(s):
    """Take the underscore-separated string s and return a CamelCase equivalent.  Initial and final underscores
    are preserved, and medial pairs of underscores are turned into a single underscore.
    Ref: https://stackoverflow.com/a/4303543/575012"""
    def camelcase_words(words):
        for word in words:
            if not word:
                yield "_"
            yield word.capitalize()
    return ''.join(camelcase_words(s.split('_')))


def reverse_trace(file) -> str:
    """
    Reverse engineer a program from the given exemplar file.
    (This is the entry/starting point from TestExemplar.py's tests.)
    :param file: A file of examples and 'reason's with extension .exem.
    :return code:
    """
    global f  # just for use in debugging
    f = file

    reset_db()
    print("\nProcessing", file)

    # Read input .exem
    if file.lower()[-5:] != ".exem":
        exit(file + " should end in '.exem' ")
    try:
        handle = open(file, "r")  # Eg, hello_world.exem
    except FileNotFoundError as err:
        print(err)
        sys.exit()
    the_trace = handle.readlines()
    handle.close()

    parse_trace(the_trace)  # Process .exem file to Insert into the examples and termination tables.
    mark_loop_likely()  # Update the loop_likely column in the examples and termination tables.
    remove_all_c_labels()  # Remove the constant (c) label, as it's currently unused.
    if debug_db:
        print(dump_table("examples"))
        print(dump_table("termination"))

    # Determine how every `reason` evaluates on every input.
    build_reason_evals()
    if debug_db:
        print(dump_table("reason_evals"))

    # To determine optimal if/elif/else order in the next step (gen_code()).
    find_safe_pretests()
    if debug_db:
        print(dump_table("pretests"))

    # Use the info in the 3 tables to generate target code.
    f_name = file[0:-5]  # target function's name
    code = "def " + f_name + "(i1):\n"  # Put it into a function named after the input file.
    for line in gen_code().splitlines(True):  # GENERATE CODE 
        code += "    " + line                 # then add an indent to each line to create the target function.
    print("\n" + code + "\n")

    # Create a file of unit tests for the function just created.

    tests = "import unittest\n\n\n" + code + "\n\n"  # TARGET FUNCTION ADDED AS WELL

    class_name = "Test" + underscore_to_camelcase(f_name)
    tests += "class " + class_name + "(unittest.TestCase):\n\n"
    for line in gen_tests(f_name).splitlines(True):  # GENERATE TESTS
        tests += "    " + line                       # Add an indent to each line, as each test is part of a class.
    tests += "\nif __name__ == '__main__':\n    unittest.main()\n"
    # Write the test file.
    try:
        test_file = class_name + ".py"
        handle = open(test_file, 'w')  # Eg, hello_world.exem -> TestHelloWorld.py
    except FileNotFoundError as err:  # Any other error catchable?
        print(err)
        sys.exit()
    handle.write(tests)
    handle.close()
    print("\n" + tests + "\n")
    return code

# If main, run Exemplar against the named .exem file (then run tests).
if __name__ == "__main__":
    if len(sys.argv) == 1 or sys.argv[1] == "":
        exit("Usage: exemplar my_examples.exem")
    class_name = "Test" + underscore_to_camelcase(sys.argv[1][0:-5])  # prime_number.exem -> TestPrimeNumber
    reverse_trace(sys.argv[1])  # RUN ALL OF THE ABOVE

    # Run the target function tests just created.
    TestClass = importlib.import_module(class_name)
    suite = unittest.TestLoader().loadTestsFromModule(TestClass)
    unittest.TextTestRunner().run(suite)
