import ast
import sys
import sqlite3  # See reset_db()
import re
from inspect import currentframe, getframeinfo  # For line #
import importlib  # To import and run the test file we create.
import unittest
from typing import List, Tuple

debug = True  # Set to True for more feedback.
debug_db = True  # True dumps db to screen near the end of each test.

"""
reverse_trace(file) reverse engineers and returns function code from the examples in the named .exem `file`.

Version 3 started 1/26/2019 to be stateful and produce scripts as well as functions.  Also, .exem's will change from 
i/o[/reason] to <inputs, >outputs, and True conditions, repeated in any order. 
Version 2 finished 10/20/2018 can also generate a while loop. This version can also handle prime_number.exem. 
'reason's are now an unlimited # of conditions.  
Version 1 finished 3/25/2018 can generate one if/elif/else. This version correctly handles fizz_buzz.exem, guess2.exem, 
and leap_year.exem. These 'reason's are 0 or 1 conditions only.

Glossary:
Loop step == Each condition of a loop_likely 'reason' maps to one of a limited # steps that is the target loop.
Pretest == A 'reason' that serves as an IF or ELIF condition above other ELIF/s (in a single if/elif/else).
Reason == The conditions the user expects will be true for the associated input in the target function == 
    SELECT line FROM example_lines WHERE line_type = 'truth'
Target function == The function to be automatically generated by Exemplar from the given examples.
"""


def clean(examples: List[str]) -> List[str]:
    """
    Remove header and line comments and trim each line.
    :param examples:  An exem file's contents.
    :return:
    """

    def denude(line: str) -> str:
        """
        Remove any surrounding whitespace and line comment from `line` and return it.
        :rtype: str
        :param line:  String to denude.
        :return:
        """
        hash_positions = positions_outside_strings(line, '#')
        if not hash_positions:  # Hash not found.
            return line.strip()
        else:
            return line[0:hash_positions[0]].strip()

    previous_line = ''
    triple_quote = "'''"
    result = []
    for line in examples:
        line = denude(line)  # See above.

        if previous_line == '':  # Then on first line.
            assert line, "The examples must begin with a triple quoted comment or an actual example, not a blank."
            if line.startswith('"""') or line.startswith("'''"):
                previous_line = 'M'  # Will now skip lines until end of Multi-line string.
                if line.startswith('"""'):
                    triple_quote = '"""'  # Instead of single quotes.
                if len(line) > 3 and line.endswith(triple_quote):
                    previous_line = 'B'  # Pretending line is blank to expect an example to start on the next line.
                assert previous_line == 'M' or previous_line == 'B'
            else:  # We're at start with no header comment.
                previous_line = 'E'  # In an example.
                result.append(line)

        elif previous_line == 'M':  # Then still in the header comment.
            if line.endswith(triple_quote):
                previous_line = 'B'  # Pretending line is blank so as to expect an example on next line.

        elif previous_line == 'B':
            assert line, "An example, not another blank line, must follow blank lines and the header comment."
            previous_line = 'E'
            result.append(line)

        elif previous_line == 'E':
            if not line:
                previous_line = 'B'  # On the next line must start an example.
            result.append(line)  # Retain both examples and their delimiters, blank lines.
    return result


def positions_outside_strings(string: str, character: str) -> List[int]:
    """
    Find and return the positions of the given character, unescaped and outside of strings, in the given string.
    :param string:
    :param character: item to search for.
    :return list of `character` positions, [] if `character` not found:
    """
    positions = []
    open_string = False
    previous_char = ''
    i = 0
    for c in string:
        if c == '"' and previous_char != '\\':
            if not open_string:
                open_string = '"'  # Note we're in a "-delimited string.
            else:  # Already in a string.
                if open_string == '"':  # String closed.
                    open_string = False
        # Repeat above, for single quote.
        if c == "'" and previous_char != '\\':
            if not open_string:
                open_string = "'"
            else:
                if open_string == "'":
                    open_string = False
        if c == character and not open_string and previous_char != '\\':
            positions.append(i)
        previous_char = c  # Set up for next iteration.
        i += 1
    return positions


def remove_c_labels(trace_line: str) -> str:
    """
    Created 2018-10-13.
    For each "c" found:
        Remove it if it is not quoted AND character to left is a digit AND character to right (if present) is not
        alphanumeric.
    Example: 'i1 % (i1-1) != 0c, (i1-1)>2c' --> 'i1 % (i1-1) != 0, (i1-1)>2'
    :param trace_line:
    :return return_value The trace_line without its c labels:
    """
    if not hasattr(trace_line, '__iter__'):  # trace_line isn't iterable.
        return trace_line
    open_string = False
    check_for_alphanumeric = False
    return_value = ""
    previous_character = ""
    for character in trace_line:
        if character == '"' and previous_character != '\\':
            if not open_string:
                open_string = '"'  # Note we're in a "-delimited string.
            else:  # Already in a string.
                if open_string == '"':  # String closed.
                    open_string = False
        # Repeat above, for single quote.
        if character == "'" and previous_character != '\\':
            if not open_string:
                open_string = "'"
            else:
                if open_string == "'":
                    open_string = False

        if check_for_alphanumeric:
            if not character.isalnum():
                return_value = return_value[0:-1]  # Elide prior "c".

        if character == "c" and previous_character.isdigit():
            check_for_alphanumeric = True  # Check during next character's processing (or after loop if at end of
            # trace_line).
        else:
            check_for_alphanumeric = False

        previous_character = character  # Set up for next iteration.
        return_value += character  # return_value built one character at a time.

    # After loop.
    if check_for_alphanumeric:  # Last two characters were a digit and "c".
        return_value = return_value[0:-1]

    return return_value


def get_last_condition(reason: str) -> str:
    """
    Find the last condition in reason. (This is useful because often it's a loop-termination condition.)
    E.g., 'i1 % (i1-1) != 0c, (i1-1)>2c' --> '(i1-1)>2c'
    :param reason:
    :return the last condition in reason:
    """
    commas = positions_outside_strings(reason, ',')
    if not commas:  # `reason` does not have multiple conditions.
        return reason
    return reason[commas[-1] + 1:].strip()  # return last condition.


def schematize(condition: str) -> str:
    """
    Could have been called replace_increment('_') because finds the increment in the given condition, eg, 13, and
    replaces it with underscore. Used to match iterations of the same loop step.  Example:
    Matching starts--v here. v--ends here.
          'i1 % (len(i1)-13) <= 0c'  ->
          'i1 % (len(i1)-_) <= 0c'
    :param condition:
    :return 'condition' with the relop and dec/increment replaced with underscore:
    """
    regex = re.compile(r'('         # Start of capture group 1. (This is a metacharacter.)
                       r'i'         # i                         i
                       r'\d+'       # #                         1
                       r'\)*'       # optional right parens     )
                       r'\s?'       # optional space            
                       r'(\+|-)'    # +|-                       -
                       r'\s?'       # optional space            
                       r'(\+|-)?'   # optional +|-              
                       r')'         # End of capture group 1.   (Another metacharacter.)
                       r'\d+'       # #, ie, the inc            13
                       r'('         # Start of capture group 4.
                       r'\)*'       # optional right parens     )
                       r'\s?'       # optional space    
                       r'((==)|(!=)|(>=)|>|(<=)|<)?'  # optional relop, e.g., <=
                       r')')  # End of capture group 4. (Groups 2 and 3 are within group 1.)
    return regex.sub(r'\1_\4', condition)


def insert_line(line_id: int, example_id: int, example_step: int, line: str) -> None:

    line_scheme = None
    if line.startswith('<'):
        line_type = 'in'
    elif line.startswith('>'):
        line_type = 'out'
    else:
        line_type = 'truth'  # True condition
        line_scheme = schematize(line)
    if line_type == 'in' or line_type == 'out':
        line = line[1:]  # Skip less/greater than symbol.

    # todo confirm that a cast here matters
    if line.isdigit():
        line = int(line)
    elif line.isdecimal():
        line = float(line)

    if example_step == 0:  # New example.
        cursor.execute('''INSERT INTO examples (eid) VALUES (?)''', (example_id,))
    cursor.execute('''INSERT INTO example_lines (el_id, example_id, step_id, line, line_scheme, line_type) 
                        VALUES (?,?,?,?,?,?)''', (line_id, example_id, example_step, remove_c_labels(line), line_scheme, line_type))

    # cursor.execute('''SELECT * FROM example_lines''')
    # print("fetchall:", cursor.fetchall())


def process_examples(examples: List) -> None:
    """
    Go through .exem file to build `examples` table and the
    termination table, with columns final_cond, output.
    """
    line_id = 0
    example_id = -1
    example_step = 0
    previous_line = 'B'
    examples = clean(examples)
    ##examples += "\n"  # To make sure last example is processed.
    for line in examples:

        if previous_line == 'B':
            assert line, "This line must be part of an example, not be blank."
            example_step = 0
            example_id += 1  # New example found.
            insert_line(line_id, example_id, example_step, line)
            previous_line = 'E'

        elif previous_line == 'E':
            if not line:
                previous_line = 'B'
            else:
                example_step += 5  # 5 instead of 1 in order to allow INSERT.
                insert_line(line_id, example_id, example_step, line)

        else:
            assert False, "previous_line must be B(lank) or E(xample), not " + previous_line

        line_id += 5  # (+=5 to allow INSERT in build_reason_evals())

""" todo                # Sanity check: confirm that each (schematized) final condition triggers identical output.
                # E.g., both 'i1 % (i1-2) == 0c' and 'i1 % (i1-4) == 0c' would
                # schematize to 'i1 % (i1-_) _ 0c' so should correlate to identical output (e.g., False).
                # MAY need to ignore examples not loop_likely.
                last_cond = remove_c_labels(get_last_condition(reason))
                # todo Needs refinement because it's not necessarily an error to have duplicate "schema" pointing
                # to the same output, as my_split.exem proved 10/23/18.
                slast_cond = schematize(last_cond)  # schematize() necessary to avoid too many conditions in the WHILE line.
                if slast_cond not in termination:  # if last_cond not in termination:
                    cursor.execute('''INSERT INTO termination (final_cond, output) VALUES (?,?)''',
                                   (last_cond, output))
                    termination[slast_cond] = output
                elif termination[slast_cond] != output:
                    print('Error: terminating condition', last_cond, 'is to output both', output, 'and',
                          termination[slast_cond])
                    sys.exit()
                cursor.execute('''INSERT INTO examples (inp, output, reason, cond_cnt) VALUES (?,?,?,?)''',
                               (inp, output, reason,                               # 1st 3 columns TEXT.
                                1 + len(positions_outside_strings(reason, ','))))  # 1 + # of commas == # of conditions in 'reason'
                reason = None
                previous_line = 'blank'"""


def mark_loop_likely() -> None:
    """
    To identify WHILE reasons, UPDATE examples.loop_likely and termination.loop_likely to 1 (true)
    to indicate those examples with 'reason's judged likely to indicate a loop in the target function.
    The criterion is simply Does the schematized(line) reappear in any 1 example?  if yes, mark all
    matches on schematized(line) in all examples as loop_likely.  This strategy can create false positives
    but is cost effective.
    todo CONFIRM The corresponding terminal conditions are then likewise set (see last cursor.execute() below).
    :return void:
    """

    def mark_sequences() -> None:
        """
        Set loop_likely to -1 to designate it as part of sequential (as opposed to selective (0) or iterative (1))
        execution.
        In this first approximation of sequential line finding, only lines pre-difference are updated to -1.
        :return:
        """
        qualified_el_ids = []
        all_qualified_el_ids = []
        cursor.execute("""SELECT COUNT(*) FROM examples""")
        number_of_examples = cursor.fetchone()[0]
        cursor.execute("""SELECT el_id, line, line_type, step_id FROM example_lines ORDER BY step_id""")
        example_lines = cursor.fetchall()
        previous_line_type, previous_line, previous_step_id = '', '', ''
        i = 0
        for row in example_lines:
            el_id, line, line_type, step_id = row
            if i == 0:
                qualified_el_ids.append(el_id)
            elif previous_line != line or previous_line_type != line_type or previous_step_id != step_id:
                # Difference reached.
                break
            else:
                qualified_el_ids.append(el_id)  # Same i/o as previous line, so note the el_id.
            i += 1
            if i == number_of_examples:  # Then, for current step_id, all examples have the same i/o.
                all_qualified_el_ids.extend(qualified_el_ids)  # Note these example lines for marking as sequential.
                qualified_el_ids, i = [], 0  # Zero out for next step_id.
            previous_line, previous_line_type, previous_step_id = line, line_type, step_id

        if len(all_qualified_el_ids) > 0:
            cursor.execute("UPDATE example_lines SET loop_likely = -1 WHERE el_id IN (" +
                           ','.join('?' * len(all_qualified_el_ids)) + ')', all_qualified_el_ids)
    """
    "SET line = ('i1 == ' || line) WHERE line IN (" + ','.join('?' * len(special_cases)) + ')'
        Do not have IFs where there is no variation between examples. So
    first need to line up the examples to find (inconsistencies and)
    variation.  So first find points of agreement and exempt them from
    the if/while analysis. So advance thru exem until divergence.
    What if i/o is same between 2 (or more) examples but not the
    'reason's?
    After process_examples()'s, turn < and > into inputs and prints
    until first difference between any two exems. Compare across
    step_id's.

    In ascending order, compare step_id's across all example_ids and mark their loop_likely = -1 until first difference
    reached.

    """
    mark_sequences()

    # cursor.execute('''UPDATE examples SET loop_likely = 1 WHERE cond_cnt > 1 OR
    #     inp IN (SELECT e1.inp FROM examples e1 WHERE INSTR(e1.reason, reason) AND e1.cond_cnt > 1)''')
    # UPDATE example_lines SET loop_likely = 1 WHERE el_id IN
    #   (

    # GROUP_BY line_scheme HAVING COUNT(*) > 1) -- assumes that

    # Pull all line_schemes from example_lines. SELECT lin
    # For each, line_schemata.add(example_id)
    # Loop thru examples_of_line.  Each element list with length > 1 causes example_id_set.add(example_id) and
    # line_set.add(schematized(line))
    # UPDATE example_lines SET loop_likely = 1 WHERE line IN (line_list) AND example_id IN (examples)
    # True resetting ? each time step_id == 0.
    cursor.execute('''SELECT example_id, line_scheme FROM example_lines ORDER BY example_id, line_scheme''')
    loop_likely_schemes = {}
    records = cursor.fetchall()
    previous_line_scheme = ''
    previous_example_id = ''
    for record in records:
        example_id = record[0]
        line_scheme = record[1]
        if line_scheme == previous_line_scheme and example_id == previous_example_id:  # Same scheme w/in same example.
            loop_likely_schemes.add(line_scheme)
    schemes_csv = ''
    for scheme in loop_likely_schemes:
        schemes_csv += scheme + ', '
    cursor.execute('UPDATE example_lines SET loop_likely = 1 WHERE line_scheme IN (' + schemes_csv + ')')
""" todo
    # Now use those newly marked examples to update the termination table.
    cursor.execute('''SELECT reason FROM examples WHERE loop_likely == 1''')
    final_conditions = []
    looping = cursor.fetchall()
    for reason in looping:
        final_conditions.append(get_last_condition(reason[0]))
    if len(looping) > 0:
        query = 'UPDATE termination SET loop_likely = 1 WHERE final_cond IN (' + \
                       ','.join('?' * len(final_conditions)) + ')'
        cursor.execute(query, final_conditions)
"""

def remove_all_c_labels() -> None:
    # The "c" labels are not needed. (Constants can have a "c" suffix in `reason` and
    # `output`.) Since they interfere with eval(), update each such record to remove_c_labels().

    cursor.execute('''SELECT el_id, line FROM example_lines WHERE line_type != 'in' ''')  # WHERE loop_likely = 0''')
    #non_looping = cursor.fetchall()
    for row in cursor.fetchall():  #non_looping:
        el_id = row[0]
        line = remove_c_labels(row[1])
        query = "UPDATE example_lines SET line = ? WHERE el_id = ?"
        cursor.execute(query, (line, el_id))


def build_reason_evals() -> None:
    """
    FOR IF CONDITION ORDERING
    Using the data of the `example_lines` table, build a `reason_evals` table that has columns for
    inp (text), `reason` (text), and reason_value (Boolean).
    reason_evals.reason_value shows T/F result of each inp being substituted for i1 in each `reason`.
    """

    # All step 5 'reason's not involved in looping.
    cursor.execute("SELECT DISTINCT line FROM example_lines WHERE line_type = 'truth' AND loop_likely = 0 AND step_id = 1")
    all_reasons = cursor.fetchall()

    # All step 0 inputs not involved in looping.
    cursor.execute("SELECT DISTINCT line FROM example_lines WHERE line_type = 'in' AND loop_likely = 0 AND step_id = 0")
    all_inputs = cursor.fetchall()
        
    locals_dict = locals()  # Used in our exec() calls.

    if debug:
        print("Function", getframeinfo(currentframe()).function, "line #", getframeinfo(currentframe()).lineno)
    for a_reason in all_reasons:
        a_reason = a_reason[0]  # There is only element 0.

        for an_inp in all_inputs:  # All inputs.
            an_inp = an_inp[0]
            if an_inp.isdigit():  # Let numbers be numbers (rather than text).
                an_inp = int(an_inp)

            # Substitute an_inp for i1 in a_reason and exec() to see if true or false. MAGIC
            exec("reason = " + a_reason, {"i1": an_inp}, locals_dict)
            reason_value = locals_dict['reason']

            # Determine and store reason_explains_io, which indicates whether inp is associated with 'reason'
            # in the examples.
            cursor.execute('''SELECT * FROM example_lines reason, example_lines inp WHERE 
                                reason.example_id = inp.example_id and reason.line = ? AND inp.line = ? AND 
                                reason.loop_likely = 0 and inp.loop_likely = 0''', (a_reason, an_inp,))
            if cursor.fetchone():  
                # Yes, the current an_inp value shares an example with a_reason.
                reason_explains_io = 1  
            else:
                reason_explains_io = 0

            if debug:
                print("input:", an_inp, " reason:", a_reason, " reason_explains_io:", reason_explains_io,
                      " reason_value:", reason_value)  # (Sqlite inserts Python None values as null.)

            # Store determinations.
            cursor.execute('''INSERT INTO reason_evals VALUES (?,?,?,?)''',
                           (an_inp, a_reason, reason_explains_io, reason_value))

    # EXPLAIN THE INPUTS WITHOUT EXPLANATION
    # Provide a   *** i1==input ***   'reason' for all reason-less examples whose input does not make any of the given
    # 'reason's true, i.e., those examples whose input does not make /any/ 'reason's true (even if there are no 'reason's)
    # fixme This should prolly go in another function.  And the above prolly needs to be re-run once new 'reason's are created.

    if 'a_reason' in locals():  # Select inputs that do not make any extant 'reason's true.
        # (Interestingly, locals_dict works here only if the line is breakpointed. 1/22/19)
        cursor.execute("SELECT inp FROM reason_evals GROUP BY inp HAVING max(reason_value)=0")

    else:  # There are /no/ 'reason's, so select /all/ inputs (from loop unlikely rows).
        cursor.execute("SELECT el_id, line FROM example_lines WHERE loop_likely = 0 AND line_type = 'in'")  #line as inp fixme

    special_cases = 0
    for row in cursor.fetchall():
        el_id = row[0]
        inp = quote_if_str(row[1])
        #special_cases.append(case[0])

        # Using inp's value, with the below modifications.
        cursor.execute("SELECT example_id, step_id FROM example_lines WHERE el_id = ? ORDER BY example_id, "
                       "el_id, step_id", (el_id,))  # First, fetch inp's el_id
        row_one = cursor.fetchone()
        el_id += 1
        example_id = row_one[0]
        reason = "i1 == " + inp
        step_id = row_one[1] + 1
        cursor.execute("""INSERT INTO example_lines (el_id, example_id, step_id, line, line_scheme, line_type) VALUES 
                            (?,?,?,?,?,?)""", (el_id, example_id, step_id, reason, schematize(reason), 'truth'))
            # "SET line = ('i1 == ' || line) WHERE line IN (" + ','.join('?' * len(special_cases)) + ')'
        special_cases += 1
    #print("I just gave ", cursor.execute(query, special_cases).rowcount, "example_lines reason ('i1 == ' || line)")
    print("I just gave", str(special_cases), "example_lines reason i1 == inp")

    if debug:
        print()


def find_safe_pretests() -> None:
    """
    For if/elif/else generation.
    Build table pretests that shows for every reason A, each reason ("safe pretest") B that is *false* with *all* of A's
    example inputs (thereby allowing those inputs to reach A if B was listed above it in an if/elif).
    """

    # All if/elif/else reasons.
    cursor.execute('''SELECT DISTINCT example_id FROM example_lines WHERE line_type = 'truth' AND loop_likely = 0''')
    all_reason_eids = cursor.fetchall()

    # Here we find the safe pretests to a_reason (again, those `reason`s false with all of a_reason's inputs).
    for reason_eid in all_reason_eids:
        reason_eid = reason_eid[0]  # The zeroth is the only element.

        sql = """
            SELECT DISTINCT reason AS potential_pretest FROM reason_evals WHERE 0 =     -- 0x that potential_pretest  
                (SELECT count(*) FROM reason_evals re2 WHERE re2.reason = 
                    potential_pretest AND re2.reason_value = 1                          -- is true 
                    AND re2.inp IN 
                (SELECT e.line FROM example_lines e WHERE e.line_type = 'in' AND        -- with input
                    e.example_id = ? AND e.loop_likely = 0))                            -- of a_reason's example  
              """  # given with a_reason (below).
        # E.g., 'i1 % 5 == 0' is a legal pretest to 'i1 % 3 == 0' (and v.v.) in Fizz_Buzz because example inputs for the
        # latter, such as 3 and 9, are not also evenly divisible by 5. And an input that is, such as 15, is an example
        # input for neither.
        cursor.execute(sql, (reason_eid,))
        pretests = cursor.fetchall()  # E.g., ('i1 % 3 == 0 and i1 % 5 == 0',)
        for pre in pretests:  # Store each.
            pre = pre[0]                                # (pretest, condition)
            cursor.execute("""INSERT INTO pretests VALUES (?,?)""", (pre, reason_eid))  # All columns TEXT


def reset_db() -> None:
    """
    Clear out the database. (A database is used for the advantages of SQL, not for multi-session storage.)
    :return: None
    """
    db = sqlite3.connect(':memory:')
    global cursor  # So db is available to all functions.
    cursor = db.cursor()

    # cursor.execute("""DROP TABLE IF EXISTS """)
    # cursor.execute("""CREATE TABLE  ()""")
    # cursor.execute("""CREATE UNIQUE INDEX  ON ()""")

    # cursor.execute("""DROP TABLE IF EXISTS io_log""")
    # cursor.execute("""CREATE TABLE io_log (
    #                     iid ROWID,
    #                     entry TEXT NOT NULL)""")

    cursor.execute('''DROP TABLE IF EXISTS example_lines''')
    cursor.execute('''CREATE TABLE example_lines (
                        el_id ROWID, -- autoincrements
                        example_id INTEGER NOT NULL,  -- example #
                        step_id INTEGER NOT NULL,  -- relative line # within the example
                        line TEXT NOT NULL,
                        line_scheme TEXT, -- schematized(line) if line_type == 'truth'
                        loop_likely INTEGER NOT NULL DEFAULT 0, -- see mark_loop_likely()
                        line_type TEXT NOT NULL)''')  # in/out/truth
    #cursor.execute('''CREATE UNIQUE INDEX e ON example_lines(el_id)''')
    cursor.execute('''CREATE UNIQUE INDEX es ON example_lines(example_id, step_id)''')

    # One record per user example.
    cursor.execute('''DROP TABLE IF EXISTS examples''')
    cursor.execute('''CREATE TABLE examples (
                        eid ROWID)''')
    #cursor.execute('''CREATE UNIQUE INDEX i ON examples(eid)''')  # Not automatic for Sqlite's primary keys.

    # One record per loop in target function, because this table notes the last condition of every such loop.
    # todo add loop id (prolly line # in target function) as primary key
    # is step_num an absolute or relative count??
    cursor.execute('''DROP TABLE IF EXISTS termination''')
    cursor.execute('''CREATE TABLE termination (
                        final_cond TEXT PRIMARY KEY NOT NULL, -- unschematized 
                        output TEXT NOT NULL,
                        step_id INTEGER, -- 0-based index
                        loop_step TEXT, -- first and original 'condition' of related loop step
                        loop_likely INTEGER NOT NULL DEFAULT 0)''')
    cursor.execute('''CREATE UNIQUE INDEX f ON termination(final_cond)''')

    # # of `reason`s * # of inputs == # of records. To show how every `reason` evaluates across every example input.
    # For if/elif/else generation.
    cursor.execute('''DROP TABLE IF EXISTS reason_evals''')
    cursor.execute('''CREATE TABLE reason_evals(
                        inp TEXT NOT NULL, 
                        reason TEXT NOT NULL, 
                        reason_explains_io INTEGER NOT NULL, -- 1 iff this inp has this reason in examples (unused)  
                        reason_value INTEGER NOT NULL)''')
    cursor.execute('''CREATE UNIQUE INDEX ir ON reason_evals(inp, reason)''')

    # # of 'reason's * (# of 'reason's - 1) == # of records.  To show
    # for every `reason`, those (single condition) reasons that can be listed above it in an elif.
    cursor.execute('''DROP TABLE IF EXISTS pretests''')
    cursor.execute('''CREATE TABLE pretests(
                        pretest TEXT NOT NULL, 
                        condition TEXT NOT NULL)''')
    cursor.execute('''CREATE UNIQUE INDEX ipc ON pretests(pretest, condition)''')


def find_rel_op(condition: str) -> Tuple:
    """
    Return the position of condition's relational operator.
    :param condition:
    :return two string positions, or () if a rel op is not found
    """
    open_string = False
    previous_character = ""
    i = 0
    start = 0
    stop = 0
    for character in condition:
        if character == '"' and previous_character != '\\':
            if not open_string:
                open_string = '"'  # Note we're in a "-delimited string.
            else:  # Already in a string.
                if open_string == '"':  # String closed.
                    open_string = False
        # Repeat above, for single quote.
        if character == "'" and previous_character != '\\':
            if not open_string:
                open_string = "'"
            else:
                if open_string == "'":
                    open_string = False
        if not start:  # Looking for >, <, ==, <=, >=, and !=.
            if not open_string and (character == '>' or character == '<' or character == '=' or character == '!'):
                start = i
        else:  # Now looking for end of relational operator.
            if character == '=':  # This is only legit 2nd character for a relational operator.
                stop = i + 1
            else:  # Must be a > or <.
                if condition[i-1] != '>' and condition[i-1] != '<':
                    sys.exit("Misplaced", condition[i-1], "character found in condition", condition)
                stop = i
            break
        i += 1

    if not stop:
        return ()
    return start, stop


def same_step(loop_step: str, condition: str) -> int:
    """
    Determine whether condition1 and condition2 represent the same loop step of a 'reason' while-loop, which they do iff
    o they share an identical side,
    o their non-identical sides vary at most in variable-value/s (Is it better to say dec/increment?).
    E.g., same_step("i1 % (i1-_) != 0", "i1 % (i1-1) != 0") --> True
    :param loop_step: a condition from loop_steps
    :param condition: current condition
    #:param last_condition: was needed when: last condition's rel op must change to terminate loop
    :return Boolean:
    """
    # opposite_rel_op = {'==': '!=', '!=': '==', '>': '<=', '<=': '>', '<': '>=', '>=': '<'}

    pos1 = find_rel_op(loop_step)

    pos2 = find_rel_op(condition)
    if not pos1:
        print("No relational operator found in", loop_step)
    if not pos2:
        print("No relational operator found in", condition)

    # rel1 = condition1[pos1[0]:pos1[1]]
    # rel2 = condition2[pos2[0]:pos2[1]]
    # my_split disproved 10/23/18 old "hurdle 1", viz., if rel1 == rel2 or (last_condition and rel1 != rel2)
    if loop_step[0:pos1[0]] == condition[0:pos2[0]]:  # Left sides identical.
        return schematize(loop_step[pos1[1]:]) == schematize(condition[pos2[1]:])  # Check other side.
    elif loop_step[pos1[1]:] == condition[pos2[1]:]:  # Right sides identical.
        return schematize(loop_step[0:pos1[0]]) == schematize(condition[0:pos2[0]])  # Check "    "
    return False


def conditions_str2List(reason: str) -> List[str]:
    """
    Determine 'reason's list of conditions (in two steps to strip() away whitespace).
    :param reason: str
    :return list of conditions, e.g., ["i1 % (i1-1) != 0c","(i1-1)==2c"]:
    """
    commas = positions_outside_strings(reason, ',')
    conditions = []
    start = 0
    for comma in commas:
        condition = reason[start: comma]
        conditions.append(condition.strip())
        start = comma + 1
    conditions.append(reason[start:].strip())  # Append last condition in 'reason'
    return conditions


def get_inc_int_pos(condition: str) -> Tuple[int, int]:
    """
    Find and return the start and stop+1 positions of the increment integer. Example: i1 % (i1-1) != 0c --> (9, 10)
    :param condition: non-schematized
    :return _pos: (start, stop+1) tuple of positions of given condition's increment integer. Or () iff missing.
    """

    # Collect any initial underscore positions into _positions.
    start = 0
    _positions = []
    for i in range(0, condition.count('_')):
        _positions.append(condition.find('_', start))
        start = _positions[-1] + 1

    schema = schematize(condition)  # Replaces dec/increment in condition with a single underscore.

    if schema.count('_') < 1:
        return ()  # schematize() found no dec/increment value in condition.  ERROR?

    # Underscores initially found?  1 of the removed values is multiple digits long?
    if len(_positions) > 0 and len(schema)+1 < len(condition):
        # Code a fix if not a very rare situation.
        print("get_increment() cannot handle abs(increments) >9 when condition has pre-existing underscores")
        sys.exit()

    if schema.count('_') > (len(_positions) + 1):
        print("Error: multiple increments found in", condition)
        sys.exit()

    # Build return value from the digit/s found at the position of the new _.
    start = 0
    for i in range(0, schema.count('_')):  # Keep checking underscores
        _pos = schema.find('_', start)     # until new one found.
        if _pos not in _positions:  # *********** NEW _ POSITION *****
            start = _pos
            while condition[_pos].isdigit():
                _pos += 1
            return start, _pos      # *********** RETURN ***********
        start = _pos + 1
    return ()  # No increment found.  ERROR?


def get_increment(condition: str) -> int:
    """
    Find and return the inc/dec-rement in the given condition.
    E.g., 'i1 % (i1-1) != 0c' --> -1
    :param condition: str
    :return signed increment, 0 if none found:
    """

    _pos = get_inc_int_pos(condition)
    if not _pos:  # _ not found
        return 0
    increment = int(condition[_pos[0]:_pos[1]])

    # Determine the increment's sign.
    sign = 1
    schema = schematize(condition)
    i_pos = schema.rfind('i', 0, _pos[0])  # Find rightmost 'i' from schema[0] to schema's (replaced) increment.
    signs = []
    for j in range(i_pos, _pos[0]):
        if schema[j] == '+' or schema[j] == '-':
            signs.append(schema[j])
    if len(signs) > 2:
        print("Error: >2 +/- signs found in schema substring", schema[i_pos: _pos[0]+1])
        sys.exit()
    elif len(signs) == 0:
        print("Error: No +/- signs found in schema substring", schema[i_pos: _pos[0]+1])
        sys.exit()
    elif len(signs) == 1:
        if signs[0] == '-':
            sign = -1
    else:
        if signs[0] != signs[1]:  # + - or - +
            sign = -1

    return sign * increment


def define_loop(loop_likely_reasons: List[str]) -> Tuple[List, List]:
    """
    Decipher the loop by noting its sequence of conditions. Define and return loop_steps, loop_step_increments and
    update the termination table.
    # todo figure out what to do about steps not given, e.g., (i1-1)>2c, if printing step errors isn't enough.
    :param loop_likely_reasons: list
    :return loop_steps, loop_step_increments:
    """
    loop_width = 0
    first_condition = ""
    loop_steps = []  # Are here built.
    loop_step_increments = []  # The change to an input variable before each condition's relational operator (includes
    # *all* reasons (perhaps uselessly)).
    for reason in loop_likely_reasons:
        reason = reason[0]  # 0 is the only key.
        last_condition_of_reason = False
        i = 0  # Count of conditions examined in this 'reason'.
        conditions = conditions_str2List(reason)
        for condition in conditions:
            increment = get_increment(condition)

            if i == (len(conditions) - 1):
                last_condition_of_reason = True
            if not loop_width:  # Still width-finding.
                if not first_condition:
                    first_condition = condition  # Needed to determine when we've cycled back to loop start.
                    loop_steps.append(condition)  # Save condition.
                else:
                    if same_step(first_condition, condition):  # Loop defined!: We've cycled back to loop start.
                        loop_width = i  # Note # of steps in while-loop. (i is correct because we're 1 past.)
                    else:  # Widen loop.
                        loop_steps.append(condition)

            if loop_width and i > loop_width:  # > needed because i resets to zero with each 'reason'.
                # While-loop already plumbed, so SANITY CHECK the `condition`, two ways.

                # 1. Each loop step must, aside from its specific increment, match its analogue in the initial loop.
                if not same_step(loop_steps[i % loop_width], condition):
                    # E.g., on step (ordinal #) 2 of a width (cardinal #) 2 loop, we must be back on step 0.
                    print("Error: Step type", schematize(loop_steps[i % loop_width]), "expected, step",
                          schematize(condition), "detected. i, loop_width, and loop_steps:\n", str(i), str(loop_width),
                          "\n", loop_steps)
                    sys.exit()

                # 2. In this single reason, the latest increment change (for this step) must equal the initial
                # increment (for this step).
                # E.g., -2    -                     [2 - 2]                !=                     [2 % 2]        at i==2
                if (increment - loop_step_increments[i - len(loop_steps)]) != loop_step_increments[i % len(loop_steps)]:
                    print("Error: Increment", increment, "is unexpected")
                    print("loop_step_increments[i - len(loop_steps)] =", loop_step_increments[i - len(loop_steps)])
                    print("loop_step_increments[i % len(loop_steps)] =", loop_step_increments[i % len(loop_steps)])
                    print("And as a result,", str(increment - loop_step_increments[i - len(loop_steps)]), "!=",
                          loop_step_increments[i % len(loop_steps)],
                          "per\n (increment - loop_step_increments[i - len(loop_steps)]) != loop_step_increments[i % len(loop_steps)]")
                    sys.exit()

            # Once for each final_cond, note its loop_step and step_num in the terminations table.
            if last_condition_of_reason:
                # Sanity check.
                if loop_width == 0:
                    print("Error: loop_width is zero at last condition. i =", i, "loop_steps =", loop_steps, "reason =",
                          reason)
                    sys.exit()
                query = '''UPDATE termination SET step_num = ?, loop_step = ?
                            WHERE loop_step IS NULL AND final_cond = ?'''
                print("query =", query)
                cursor.execute(query, (str(i % loop_width), loop_steps[i % loop_width], get_last_condition(reason)))

            loop_step_increments.append(increment)
            i += 1
    return loop_steps, loop_step_increments


def quote_if_str(incoming: str) -> str:
    """
    Unless incoming is a number, "True", or "False", return it wrapped in single quotes.
    :param incoming:
    :return:
    """
    if incoming.isnumeric() or incoming == 'True' or incoming == 'False':
        return incoming  # Hands off a number or Boolean.

    escaped = incoming.translate(str.maketrans({"'": r"\'"}))  # Escape any single quotes.
    return "'" + escaped + "'"


def gen_code() -> str:
    """
    Use the info in the tables to generate Python if/elif/else and while loops.
    todo refactor
    :return: Python code as `code`
    """

    code = ''  # To be returned

    # Pull the example_lines whose flow pattern is sequence.
    sql = "SELECT line, line_type FROM example_lines WHERE loop_likely = -1"
    cursor.execute(sql)
    rows = cursor.fetchall()
    if len(rows) == 0:
        print("*Zero* loop_likely==-1 (sequential) rows found.")
    for row in rows:
        line, line_type = row
        if line_type == 'in':
            if line == '':
                code += 'input()\n'
            else:
                code += 'var = ' + quote_if_str(line) + '\n'  # todo improve var naming!
        elif line_type == 'out':
            code += 'print(' + quote_if_str(line) + ")\n"

    # Pull the IF/ELIF/ELSE conditions, in that order. (old: Reasons where loop_likely==0 map to conditions 1:1.)
    sql = """
        SELECT line, example_id, step_id AS r1 FROM example_lines WHERE line_type = 'truth' AND loop_likely = 0
            ORDER BY (SELECT COUNT(*) FROM pretests WHERE pretest = r1) DESC, LENGTH(line) DESC, 
            line -- (for order stability) 
         """
    cursor.execute(sql)
    conditions = cursor.fetchall()  # E.g., [('i1 % 5 == 0',), ('i1 % 3 == 0',)]
    if len(conditions) == 0:
        print("*Zero* line_type 'truth', loop_likely==0 rows found. The exact query executed: " + sql)
    else:
        # The most selective condition, i.e., the one that can most commonly serve as a pretest, should be
        # the IF condition. (+1 Insightful)
        # todo To help diagnose user error, add a test ensuring that this 'reason' is a valid pretest to all other 'reason's
        code += "if " + conditions[0][0] + ":\n"
        code += "    return " + quote_if_str(get_output(conditions[0][1], conditions[0][2])) + '\n'  # get_output(reason_eid, step_id)
        del(conditions[0])  # IF is done.

        # Add the ELIF and ELSE conditions and their consequents based on the same criteria (order from the SELECT).
        for condition in conditions:
            reason_eid = condition[1]
            step_id = condition[2]
            condition = condition[0]
            if condition == "True":
                code += "else:\n"
            else:
                code += "elif " + condition + ":\n"
            code += "    return " + quote_if_str(get_output(reason_eid, step_id)) + '\n'

    # Pull the WHILE conditions.
    sql = """
        SELECT line AS r1 FROM example_lines WHERE line_type = 'truth' AND loop_likely = 1 ORDER BY step_id DESC, 
            line -- (for order stability) 
         """
    cursor.execute(sql)
    loop_likely_reasons = cursor.fetchall()  # E.g., [('i1 % 5 == 0',), ('i1 % 3 == 0',)]
    if len(loop_likely_reasons) == 0:
        return code  # *********************************** RETURNing because no WHILE loop ***

    loop_steps, loop_step_increments = define_loop(loop_likely_reasons)  # *** DEFINE_LOOP() ***
    print("loop_steps:", loop_steps)
    print("increments:", loop_step_increments)

    # Loop info has been collated. Now generate loop code using found steps, termination conditions, and return values.

    i = 1
    code += "\n"
    for step in loop_steps:
        code += "accum" + str(i) + " = " + str(-1 * loop_step_increments[i-1]) + "\n"  # E.g., "accum1 = 1\n"
        i += 1

    # Add: WHILE the termination conditions are NOT met, ANDed.
    code += "while "
    cursor.execute('''SELECT final_cond, output, loop_step FROM termination WHERE loop_likely = 1 ORDER BY step_num''')
    terminations = cursor.fetchall()
    assert len(terminations) > 0, "Error: Nothing found in termination table"

    i = 1  # Start at 1 for user-facing names.
    for row in terminations:  # Write while's condition and set up termination list.
        last_cond, output, loop_step = row  # E.g., ['(i1-3)==2c', 'True', '(i1-1)>2c']
        # Replace original condition's dec/increment with one of our accumulators.
        _pos = get_inc_int_pos(loop_step)
        # Remove its "c" labels.
        code += remove_c_labels(loop_step[0:_pos[0]] + "accum" + str(i) + loop_step[_pos[1]:]) + " and "
        # So that could be: += "(i1-accum1)>2 and "
        i += 1
    code = code[0:len(code)-5] + ":\n"  # Clip off last " and ", and WHILE line finalized with ":\n"
    # E.g., "while i1 % (i1-accum1) != 0 and (i1-accum2)>2:\n"

    # Within the loop, each step's accumulator must increment.
    i = 1
    for step in loop_steps:
        code += "    accum" + str(i) + " += " + str(-1 * loop_step_increments[i - 1]) + "\n"
        i += 1
    # E.g., \taccum1 += 1

    # Loop done, now add the if/elif/else gauntlet of termination conditions with payload.
    # cursor.execute('select final_cond, output from termination where loop_likely=1 order by step_num')
    # terminations = cursor.fetchall()
    code += "if "
    i = 1
    for row in terminations:
        last_cond, output, loop_step = row
        _pos = get_inc_int_pos(last_cond)  # E.g., (5, 6)
        code += remove_c_labels(last_cond[0:_pos[0]] + "accum" + str(i) + last_cond[_pos[1]:])
        code += ":\n    return " + output + "\nelif "  # ELIF and RETURN
        i += 1
    code = code[0:len(code)-5]  # Clip off "elif "
    # E.g., i1 % (i1-accum1) == 0:\n\treturn False

    return code


def get_output(reason_eid: int, step_id: int) -> str:
    """
    For given 'reason', return the corresponding 'output' from the examples.
    E.g., 'i1 == 2c' --> "True"
    N.B. 'reason' must pre-exist in examples table.
    N.B. So far this function is for if/elif/else generation only.
    N.B. Even though the same `reason` may be re-used across examples, as long as there's only one IF, `reason`
    is sufficient to determine the output because the output can reference input only via variables (i1, i2, ...),
    not constants.
    :param reason: text
    :return: the output the user associated with the given reason in his/her examples.
    """
    query = '''SELECT line FROM example_lines WHERE line_type = 'out' AND example_id = ? AND step_id > ? AND 
                        loop_likely = 0 ORDER BY step_id LIMIT 1'''
    cursor.execute(query, (reason_eid, step_id))
    fetchone = cursor.fetchone()
    if fetchone is None:
        cursor.execute("""SELECT step_id FROM example_lines WHERE line_type = 'out' AND example_id = ?  AND 
                        loop_likely = 0 ORDER BY step_id""", (reason_eid,))
        print("With example_id "+str(reason_eid)+" and step_id "+str(step_id)+
              ", this query returned zero rows:\n"+query)
        step_ids = ''
        for row in cursor.fetchall():
            step_ids += str(row[0]) + ', '
        sys.exit("The step_id's matching those criteria are " + step_ids)
    return fetchone[0]


def dump_table(table: str) -> str:
    """
    SHOW EXAMPLE............
    (Called when global variable debug_db is True.)
    :return void:
    """

    print_me = "all " + table + ":\n("
    cursor.execute('''SELECT * FROM ''' + table)
    all_rows = cursor.fetchall()
    for description in cursor.description:
        print_me += description[0] + ", "
    print_me = print_me[0:-2] + ")\n"  # Rtrim last ", "

    for row in all_rows:
        print_me += '('
        for field in row:
            print_me += str(field) + ", "
        print_me = print_me[0:-2] + "),\n"
    return '[' + print_me[0:-2] + ']'  # Rtrim last ',\n'


def gen_tests(f_name: str) -> str:
    """
            jokes()  # The function under test. Utility functions print() and input() assign to global io_trace.
        self.assertEqual(self.get_expected("jokes.exem"), io_trace)

    Generate the text of a unit test file that exercises the target function with the given i/o.
    """
    cursor.execute('''SELECT inp.line, output.line, inp.example_id FROM example_lines inp, example_lines output 
                        WHERE inp.example_id = output.example_id AND inp.line_type = 'in' AND output.line_type = 'out'
                        AND (inp.step_id = 0 OR output.step_id = 0) ORDER BY inp.example_id, output.step_id DESC''')
    all_examples = cursor.fetchall()  # The DESC and `continue` below implements MAX(output.step_id) per example_id
    test_code = ""
    i = 1  # For appending to the test name.
    previous_example_id = -1
    for row in all_examples:
        inp, output, example_id = row
        if example_id == previous_example_id:
            previous_example_id = example_id
            continue
        # Create one test per example.
        test_code += "def test_" + f_name + str(i) + "(self):\n"
        # code += "    i1 = " + inp + "\n"  # (i1 may be referenced by output as well.)
        # code += "    self.assertEqual(" + output + ", " + f_name + "(i1))\n\n"
        test_code += "    " + f_name + "()  # The function under test.\n"  # TODO need formal params!!!!!!!!
        test_code += "    self.assertEqual(self.get_expected('" + f_name + ".exem'), io_trace)"

        previous_example_id = example_id
        i += 1
    return test_code


def underscore_to_camelcase(s: str) -> str:
    """Take the underscore-separated string s and return a CamelCase equivalent.  Initial and final underscores
    are preserved, and medial pairs of underscores are turned into a single underscore.
    Ref: https://stackoverflow.com/a/4303543/575012"""
    def camelcase_words(words):
        for word in words:
            if not word:
                yield "_"
            yield word.capitalize()
    return ''.join(camelcase_words(s.split('_')))


def from_file(file: str) -> List[str]:
    try:
        handle = open('./' + file, "r")  # Eg, hello_world.exem
    except FileNotFoundError as err:
        print(err)
        sys.exit()
    lines = handle.readlines()
    handle.close()
    return lines


def to_file(file: str, text: str) -> None:
    try:
        handle = open('./' + file, 'w')  # Eg, TestHelloWorld.py
    except FileNotFoundError as err:  # Any other error catchable?
        print(err)
        sys.exit()
    handle.write(text)
    handle.close()


def formal_params() -> str:
    result = ''
    sql = "SELECT example_id, line, line_type FROM example_lines ORDER BY example_id, step_id"
    cursor.execute(sql)
    rows = cursor.fetchall()
    previous_example_id = ''
    argument_types = {}  # Associates a counter with a data type.
    argument_index = 0
    arguments_count = sys.maxsize  # Total # of args, counting from zero.
    goto_next_example = False
    i = 0
    for row in rows:
        example_id, line, line_type = row

        if i > 0 and example_id != previous_example_id:  # Then up to a new example.
            argument_index -= 1  # Go back 1.
            if argument_index != arguments_count:
                sys.exit("In example " + str(example_id) + ',' + str(arguments_count+1) + " arguments expected, " +
                         str(arguments_count+1) + " arguments found.")
            argument_index = 0  # We've returned to the first input argument (if it exists).
            goto_next_example = False  # Reset this, as we've arrived.

        if line_type == 'out':
            if arguments_count < sys.maxsize and argument_index < arguments_count:
                sys.exit("Last " + str(arguments_count - argument_index) + " argument_types are missing (of " +
                         str(arguments_count) + ") in example " + str(example_id))
            goto_next_example = True

        if line_type == 'in' and not goto_next_example:  # Then work the data type.
            data_type = type(ast.literal_eval(line))  # Determine line's data type.
            if arguments_count == sys.maxsize:  # Then still counting arguments (from zero).
                argument_types[argument_index] = data_type
            if arguments_count < sys.maxsize and argument_index not in argument_types:
                sys.exit("Too many argument_types in example " + str(example_id) + " (Line content: " + line + ')')
            if data_type is not argument_types[argument_index]:
                if data_type is str:
                    print("argument_types[" + argument_index + "] was thought to be of type " +
                          argument_types[argument_index] + " but is now TEXT to allow value '" + line + "'")
                    argument_types[argument_index] = str
                elif data_type is float and argument_types[argument_index] is int:
                    print("Example " + str(example_id) + " has argument " + line + " where a value of type INT was expected."
                        + " The argument's data type is now FLOAT to accommodate it.")
                    argument_types[argument_index] = float
                else:
                    sys.exit("Example " + str(example_id) + " has argument " + line + " where a value of type " +
                             argument_types[argument_index] + " was expected.")

        # Set up next iteration.
        previous_example_id = example_id
        argument_index += 1
        i += 1

    for i in argument_types:
        result += 'i' + i+1 + ": " + argument_types[i+1] + ", "  # Creating formal param list.
    return result.rstrip(", ")


def reverse_trace(file: str) -> str:
    """
    Reverse engineer a function from its .exem `file`.
    :param file: A file of examples and 'reason's with extension .exem.
    :param examples: A string of examples, as from an HTML textarea.
    :return code:
    """
    global f  # just for use in debugging
    f = file  # for debugging

    # Read input .exem
    print("\nProcessing", file)
    if file.lower()[-5:] != ".exem":
        sys.exit(file + " should end in '.exem' ")
    examples = from_file(file)

    reset_db()
    process_examples(examples)  # Process .exem file to Insert into the examples and termination tables.
    remove_all_c_labels()  # Remove the constant (c) label, as it's currently unused.
    
    mark_loop_likely()  # Update the loop_likely column in the examples and termination tables.
    if debug_db:
        print(dump_table("example_lines"))
        print(dump_table("termination"))

    # Determine how every `reason` evaluates on every input.
    build_reason_evals()
    if debug_db:
        print(dump_table("reason_evals"))

    # To determine optimal if/elif/else order in the next step (gen_code()).
    find_safe_pretests()
    if debug_db:
        print(dump_table("pretests"))

    # Use the info in the 3 tables to generate target code.
    f_name = file[0:-5]  # target function's name
    code = "def " + f_name + "(" + formal_params() + "):\n"  # Put it into a function named after the input file.
    for line in gen_code().splitlines(True):  # *** GENERATE CODE ***
        code += "    " + line                 # then add an indent to each line to create the target function.
    print("\n" + code + "\n")

    # Create a file of unit tests for the function just created.

    starter = "".join(from_file("starter"))  # Contains below line and mocked print() and input().
    # "# AUTOGENERATED FILE\n\nimport unittest\n\n\n" + code + "\n\n"  # Note "code".  That's the gen'ed function.
    starter = starter.replace('<function under test>', code, 1)

    class_name = "Test" + underscore_to_camelcase(f_name)
    class_signature = "class " + class_name + "(unittest.TestCase):"
    starter = starter.replace('<class signature>', class_signature, 1)
    for line in gen_tests(f_name).splitlines(True):  # *** GENERATE TESTS ***
        starter += "    " + line                       # Add an indent to each line, as each test is part of a class.
    starter += "\n\nif __name__ == '__main__':\n    unittest.main()\n"
    # Write the test file.
    test_file = class_name + ".py"
    to_file(test_file, starter)
    print("\n" + starter + "\n")

    return code


# If main, run Exemplar against the named .exem file (then run tests).
if __name__ == "__main__":
    if len(sys.argv) == 1 or sys.argv[1] == "":
        sys.exit("Usage: exemplar my_examples.exem")
    reverse_trace(file=sys.argv[1])  # RUN ALL OF THE ABOVE

    # Run the target function tests just created.
    class_name = "Test" + underscore_to_camelcase(sys.argv[1][0:-5])  # prime_number.exem -> TestPrimeNumber
    TestClass = importlib.import_module(class_name)
    suite = unittest.TestLoader().loadTestsFromModule(TestClass)
    unittest.TextTestRunner().run(suite)
